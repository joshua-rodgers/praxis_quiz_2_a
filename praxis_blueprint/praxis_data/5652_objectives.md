# Praxis® Computer Science – Content Topics & Discussion Questions

*From The Praxis® Study Companion.*

---

## About the Test

The Praxis Computer Science test assesses the knowledge and competencies needed for a beginning secondary-level computer science teacher. Examinees typically hold a bachelor’s degree emphasizing computer science or CS education. Tested areas include core CS concepts, algorithms & computational thinking, programming, data, and computing systems & networks. The test aligns generally with national guidance (K–12 CS Framework 2016; CSTA K–12 CS Standards 2017; ISTE Computational Thinking Competencies) but is not tied to any single curriculum. Some questions may be unscored.

---

## Content Topics Overview

Content Topics outline the knowledge and skills measured. In lists, **e.g.** indicates illustrative (not exhaustive) examples; **i.e.** indicates a complete list. “Discussion Questions” appear throughout to help you self-assess and integrate concepts into classroom practice; no official answers are provided.

---

# I. Impacts of Computing

### A. Impact, Obstacles, & Effects

1. **Computing as creativity / problem solving / communication / innovation**

   * Showcase creativity.
   * Solve problems.
   * Enable communication & collaboration.
   * Foster innovation across fields & careers.
2. **Obstacles to equal access**

   * Identify barriers across groups (e.g., gender, socioeconomic status, disability/accessibility) and their impacts.
   * Identify digital divide factors.
   * Match obstacles to effective solutions.
3. **Beneficial vs. harmful effects & trade-offs**

   * Analyze social, economic, cultural impacts (positive & negative).
   * Identify trade-offs across impacts.

### B. Intellectual Property, Ethics, Privacy, Security

1. **Protecting intellectual property (IP)** (e.g., Creative Commons, open source, copyright)

   * Use correct IP vocabulary.
   * Select appropriate IP protection for a context.
   * Compare trade-offs among IP methods.
2. **Ethical vs. unethical computing practices**

   * Identify practices in context.
   * Describe social, economic, cultural implications.
   * Determine when a practice is ethical or legal.
3. **Privacy & security in a digital world**

   * Use correct terminology to describe issues.
   * Select strategies to safeguard privacy & ensure security.
   * Compare local vs. cloud storage trade-offs.
   * Identify how digital services collect user information.

#### Discussion Questions – Impacts of Computing

* Examples of computing innovations?
* Ways computing enables creativity & innovation?
* Impacts (positive/negative) on quality of life?
* How do computers enable communication & collaboration in *your* life/classroom?
* Obstacles to equal access (gender, SES, accessibility)? Solutions?
* What is the *digital divide*? Examples?
* Given an innovation, identify beneficial **and** harmful impacts.
* Value of copyright? Classroom implications?
* What is open source? Common examples?
* Examples of Creative Commons–licensed materials; how are CC licenses different?
* Ethical vs. unethical computing practices & their societal implications?
* Strategies to safeguard privacy & ensure security?
* Examples of data stored locally vs. in the cloud; pros/cons of each?
* What info do digital services collect about users? Classroom impact?

---

# II. Algorithms & Computational Thinking

### A. Abstraction, Patterns, Decomposition, Number Bases, Formats

1. **Abstraction**

   * Order levels in an abstraction hierarchy (low→high).
   * Identify abstractions in context.
   * Remove details to generalize a solution.
2. **Pattern recognition & problem decomposition**

   * From data (tables, etc.), detect patterns & candidate algorithms.
   * Identify algorithm components for a problem.
   * Identify actions & actors when decomposing.
   * Choose appropriate decomposition strategies.
3. **Number base conversion**

   * Convert among bases (binary, decimal, hexadecimal, etc.).
   * Compare representations across bases.
4. **Multiple algorithm formats** (natural language, flowcharts, pseudocode)

   * Interpret diagrams (given symbol legend).
   * Compare across formats.
   * Trace & analyze algorithms in each.
   * Detect sequencing errors.

### B. Algorithm Analysis, Search/Sort, Recursion, Randomization

1. **Computing limitations & heuristics**

   * Distinguish linear, quadratic, exponential, logarithmic behavior.
   * Recognize unsolvable problems.
   * Identify factors blocking solvability.
   * Situations suited to heuristics.
   * Recognize time/space limitations.
2. **Searching & sorting**

   * Trace algorithms; predict outputs & intermediates.
   * Count comparisons in linear vs. binary search.
3. **Simple recursion** (e.g., *n!*; sum 1..n)

   * Trace simple recursive algorithms.
   * Fill in missing steps.
   * Identify base case, recursive call.
   * Detect errors.
   * Provide equivalent iterative version.
4. **Randomization**

   * Appropriate uses across applications.
   * Distinguish random vs. pseudorandom.

#### Discussion Questions – Algorithms & Computational Thinking

Self-check prompts include: levels of abstraction; bit-level representations (numbers, chars, colors); deriving an algorithm from data; decomposition practice; conversions (decimal/binary/octal/hex); tracing across representations; familiarity with test pseudocode; missing/out-of-order steps; solvable vs. unsolvable problems; growth-rate categories; heuristic use cases; comparison-based sorts & their comparisons; linear vs. binary search comparisons; tracing recursion & recursive-call counts; translating recursive ↔ iterative; uses of randomization; random vs. pseudorandom; range-scaling of random numbers.

---

# III. Programming

## A. Control Structures, Operators, Variables, Correctness, Extensibility/Modifiability/Reusability

1. **Write/modify programs**

   * Describe program behavior; pick correct implementation.
   * Fill in missing code.
   * Order statements correctly.
   * Predict effect of code changes.
2. **Analyze for correctness**

   * Trace & report outputs/variable values.
   * Identify inputs yielding given outputs.
   * State purpose / choose correct code for purpose.
   * Identify valid preconditions & postconditions.
   * Compare code segments / algorithms.
   * Classify error types (syntax, runtime, compile-time, overflow, round-off, logic).
   * Locate & correct errors.
3. **Extensibility / Modifiability / Reusability**

   * Define terms.
   * Compare functionally equivalent code differing in these qualities.
   * Prefer constants/variables over literals where appropriate.
   * Spot parameterization opportunities.
   * Improve code for greater reuse/extensibility.
   * Suggest changes to improve given code.
4. **Basic constructs: sequence, selection, iteration**

   * Trace & predict.
   * Map inputs→outputs.
   * Describe/choose correct implementation.
   * Fill missing code.
   * Find equivalent code segments.
   * Identify constructs in use & which are needed.
   * Convert non-iterative code to iterative.
5. **Standard operators & precedence** (assignment, arithmetic, relational, logical)

   * Trace & evaluate expressions / outputs.
   * Map inputs→outputs.
   * Choose correct implementation.
   * Fill missing code.
   * Recognize equivalences.
   * Order statements correctly.
   * Apply Boolean algebra for equivalence.
   * Translate between Boolean expressions & code/English.
   * Implement formulas (incl. fractions) correctly.
   * Evaluate arithmetic expressions.
6. **Variables & data types**

   * Identify types (int, floating point, string, Boolean, array/list, etc.).
   * Recognize when to convert types.
   * Trace & predict outputs.
   * Map inputs→outputs.
   * Choose/complete code for purpose.
   * Recognize equivalent code.
   * Order statements.
   * Distinguish int vs. float; int vs. float division.
   * Benefits of each type.
   * Global vs. local scope.
   * Choose most appropriate type for context.
   * Sequence string operations for target output.

## B. Procedures, Events, UX, Data Structures, Debugging, Documentation, Libraries/APIs, IDEs, Paradigms, OOP

1. **Procedures (functions/methods) w/ parameters & returns**

   * Trace & predict.
   * Map inputs→outputs.
   * Describe/choose correct code.
   * Complete missing code.
   * Recognize equivalences.
   * Order statements.
   * Trace reference semantics (objects/arrays passed).
   * Trace nested calls.
2. **Event-driven programming** (sensors, messages, clicks, etc.)

   * Trace/predict.
   * Map inputs→outputs.
   * Describe/choose correct code.
   * Fill missing code.
   * Spot asynchronous-event errors.
   * Identify concurrency aspects.
3. **Usability & user experience (UX)**

   * Improve code for usability/UX.
   * Provide meaningful error messages.
   * Add accessibility features.
4. **Data structures: dictionaries/maps, stacks, queues**

   * Identify by behavior/use.
   * Select best structure for goals/constraints/context.
   * Trace code using the structure.
5. **Debugging & test cases**

   * Choose most useful tests.
   * Distinguish error types (overflow, round-off, syntax, runtime, compile-time, logic).
   * Outline debugging techniques (e.g., strategic print statements).
   * Empirical testing vs. proof.
   * Find & fix code errors.
6. **Documentation quality**

   * Recognize characteristics of good documentation.
   * Distinguish good vs. poor practices.
7. **Feedback for quality code**

   * When to use code reviews, peer feedback, end-user feedback.
8. **Libraries & APIs**

   * Identify correct calls & return use from API specs.
   * Reasons to reuse libraries vs. write from scratch.
   * Example application areas (math, RNG, etc.).
9. **Input validation**

   * Effective validation strategies.
   * Distinguish validation (range/format) vs. verification (e.g., password).
   * Improve code needing validation.
10. **IDEs**

* Components.
* Pros/cons of using an IDE.
* Costs/benefits of context editors.

11. **Low- vs. high-level languages**

* Identify characteristics of each.

12. **Programming paradigms**

* Procedural terminology.
* Object-oriented terminology.
* Compare paradigms.

13. **Object-oriented concepts**

* Identify classes, instance vars, methods from diagrams.
* Benefits of inheritance & encapsulation.
* Overloading vs. overriding distinctions.

14. **Compilation vs. interpretation**

* Differences between the two.
* Source vs. object code.

### Discussion Questions – Programming

Prompts cover: tracing, describing, and completing pseudocode; analyzing correctness; error types & fixes; pre/postconditions; improving extensibility/modifiability/reusability; replacing literals with constants/variables; tracing & converting loops; tracing selection constructs; evaluating expressions & precedence; Boolean algebra equivalence; decimal vs. integer division; core data types & conversions; memory representation; variable scope; tracing parameterized/nested procedures; handling external events & concurrency; addressing usability/accessibility; working with dictionaries/maps, stacks, queues; debugging strategies & test-case selection; documentation quality; leveraging code reviews & feedback; using libraries & APIs; input validation approaches; IDE features; low- vs. high-level languages; comparing paradigms; overloading vs. overriding.

---

# IV. Data

## A. Digitalization, Encryption/Decryption, Computational Tools

1. **Bits as universal digital medium**

   * Perform bit/byte calculations.
   * Determine storage size needed.
   * Encode/decode using a described scheme.
   * Lossy vs. lossless compression.
   * Why binary underlies computer operation.
2. **Encryption & decryption**

   * Encoding vs. encryption.
   * Trade-offs in encrypting data.
3. **Computational tools for data analysis** (incl. spreadsheets)

   * Transform data for usefulness.
   * Identify data needing cleaning before use.
   * Use spreadsheet operations (formulas, filters, sorts, charts/graphs) for analysis & visualization.

## B. Simulation, Modeling, Data Manipulation

1. **Computational simulation & modeling**

   * What questions can a simulation answer?
   * What data/process are required?
   * Trace code in simulation context.
   * Identify missing simulation code.
   * Impact of changes (variables, data volume).
   * Applications of simulation/modeling.
2. **Store, manage, manipulate data**

   * File/database terminology.
   * File size measures (byte, kilo, mega, giga, tera, peta).
   * Storage issues: scale, redundancy, backup.
3. **Data collection, aggregation, generation**

   * Benefits of publicly available data sets.
   * Data from surveys & sensors.
   * Crowdsourcing & citizen science examples.
   * Choose appropriate data-collection methods for a context.

### Discussion Questions – Data

Reflection prompts: bits/binary fundamentals; encoding vs. encryption examples; lossy vs. lossless compression; transforming raw data; using spreadsheets to transform/visualize; simulation & modeling examples; finding missing simulation code; file-size relationships; redundancy/scale/backup impacts; data collection/aggregation/generation methods; crowdsourcing & citizen science; when simulation/modeling helps; estimating storage needs; base conversions (binary/decimal/hex); spotting simulation errors; issues in data processing; data generated from simulation.

---

# V. Computing Systems & Networks

## A. Operating Systems, System Types, Device Communication, Cloud

1. **Operating systems (OS) coordinate hardware & software**

   * Hardware components & functions.
   * Software components & functions.
   * Common OS tasks.
   * Resource constraints affecting functionality.
2. **Embedded systems** (IoT, ATMs, medical devices, etc.)

   * Define embedded system.
   * Define Internet of Things (IoT) & its uses.
   * Role of sensors.
3. **System types** (desktop, mobile, cluster, etc.)

   * Capabilities, features, uses.
   * Evaluation criteria for comparison.
4. **Layered abstractions** (hardware → system software → applications)

   * Assign components to abstraction layers.
5. **Fetch–Decode–Execute cycle**

   * Describe what happens in each step & order correctly.
6. **Local vs. network vs. cloud computing & storage**

   * Performance, cost, security, reliability, collaboration trade-offs.
   * Ways to store binary data.
7. **Communication between devices**

   * Compare wireless systems.
   * Compare wired systems.
   * Compare network types.

## B. Networks, Security, & the Web

1. **Network components**

   * Identify hardware devices & functions.
   * Possible abstraction models.
2. **Network functionality factors**

   * Define bandwidth, load, latency.
   * Estimate needed bandwidth/data size.
   * Identify critical resources.
3. **Internet & Web protocols**

   * Purpose of protocols; common Internet/Web protocols.
   * IPv4 vs. IPv6.
   * Parts of a URL (protocol, subdomain, domain, port, path).
   * Hierarchical DNS naming.
   * Purpose/function of IP addressing.
   * How Internet protocols address reliability, redundancy, error handling.
4. **Security strategies**

   * Characteristics of strong passwords (length, bits/char).
   * Digital & physical security approaches.
   * Trade-offs in using security measures (encryption, decryption, digital signatures/certificates).
5. **Cybersecurity pillars**

   * Confidentiality, Integrity, Availability, Nonrepudiation, Authentication.
6. **Web components**

   * HTTP, HTML, browsers, servers, clients.
   * Uses of markup languages.
   * Roles of browsers/servers/clients.

### Discussion Questions – Computing Systems & Networks

Consider: common OS tasks; hardware & software roles; meaning of IoT; ordering fetch–decode–execute steps; trade-offs of local/network/cloud computing & storage; comparing wireless & wired communication systems; comparing network types; identifying network hardware & functions; explaining bandwidth/load/latency; describing how the Internet works; digital & physical security strategies you’ve used; explaining confidentiality, integrity, availability, nonrepudiation, authentication; identifying core Web components (HTTP, HTML, browsers, servers, clients).

